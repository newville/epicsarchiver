#!/usr/bin/env python3.8

# main pvarch application

import sys
import os
import time
from argparse import ArgumentParser

try:
    import epicsarchiver
except:
    print('cannot import epicsarchiver')
    sys.exit(1)

from epicsarchiver import Cache, Archiver

def set_runinfo():
    master  = ArchiveMaster()
    for i in master.runs.select(where='1=1 order by start_time desc limit 2'):
        dbname = i['db']
        if dbname != master.arch_db:
            print('setting run information for ', dbname)
            master.set_runinfo(dbname)
            print('done.')
    master.close()

def next_archive():
    master  = ArchiveMaster()
    old_dbname  = master.arch_db
    next_db = master.make_nextdb()

    master.stop_archiver()
    master.set_currentDB(next_db)

    master.close()
    run_archive(action='start')

def save_archives(args):
    " save archives to gzipped ascii files"
    m  = MasterDB()
    for db in (m.arch_db, master_db):
        m.save_db(dbname=db)
        if db in args: args.remove(db)

    for db in args:
        m.save_db(dbname=db)
    m.close()

def clean_web_datafiles():
    """clean old files from web data / plot directory:
    files older than 2 days will be deleted"""
    now = time.time()
    nclean = 0
    for i in os.listdir(data_dir):
        fname = os.path.abspath(os.path.join(data_dir,i))
        if (os.path.isfile(fname) and i.startswith(webfile_prefix)):
            mtime = os.stat(fname)[8]
            if (now - mtime) > 2*SEC_DAY:
                os.unlink(fname)
                nclean = nclean+1
    print('removed %i files from %s' % (nclean,data_dir))

def list_archives():
    master  = MasterDB()
    for i in master.runs_report():
        print(i)
    master.close()

def run_archive(action='start'):

    if not os.path.exists(logdir):   os.mkdir(logdir)
    sout    = os.path.join(logdir, "pvarch.log")
    serr    = os.path.join(logdir, "pvarch.err")
    pidfile = os.path.join(logdir, "pvarch.pid")

    dbconn  = cpool.get()
    a = Archiver(dbconn=dbconn)
    if 'start'==action:
        pid,status = a.get_pidstatus()
        if (pid != 0 and status != 'offline'):
            ret = a.get_nchanged(minutes=2, limit=10)
            if ret >  5:
                print("Archive appears to be running... try 'restart'?")
                cpool.put(dbconn)
                return

    startstop(stdout=sout,stderr=serr, pidfile=pidfile,
              process_name='pvarch', action=action)

    dbconn  = cpool.get()
    a = Archiver(dbconn=dbconn)
    if 'stop'==action:
        a.set_pidstatus(pid=0,status='stopping')
        time.sleep(1.0)

    elif 'start'==action:
        a.mainloop()

def run_cache(action=None):
    # not that cache is best run in it's own thread!

    if not os.path.exists(logdir):
        os.mkdir(logdir)
    sout    = os.path.join(logdir, "cache.log")
    serr    = os.path.join(logdir, "cache.err")
    pidfile = os.path.join(logdir, "cache.pid")

    dbconn  = cpool.get()
    c = Cache(dbconn=dbconn, pidfile=pidfile)

    if 'start'==action:
        status = c.get_cache_status()
        if status == 'running':
            ret = c.cache.select(where="ts> %i order by ts" % (time.time()-30.0))
            if len(ret) >  5:
                print("Archive appears to be running... try 'restart'?")
                cpool.put(dbconn)
                return
    elif 'stop'==action:
        c.db.set_autocommit(1)
        c.set_cache_status('stopping')
        c.set_cache_pid(0)
        c.shutdown()
        if action == 'stop':
            return
        else:
            action = 'start'

    def cache_thread(fcn_action='start'):
        dbconn  = cpool.get()
        c = Cache(dbconn=dbconn)
        if 'stop'==fcn_action:
            c.db.set_autocommit(1)
            c.set_cache_status('stopping')
            c.set_cache_pid(0)
            time.sleep(0.50)
        else:
            c.mainloop()

    if action=='start' and False:
        cache_thread()
    else:
        startstop(stdout =sout,stderr=serr, pidfile=pidfile,
                  process_name='pvcache', action=action,
                  func=cache_thread, fcn_action=action)


def read_pid(name='cache'):
    pidfile = "%s/%s.pid" % (logdir,name)
    try:
        pf  = open(pidfile,'r')
        pid = int(pf.read().strip())
        pf.close()
    except IOError:
        pid = None
    return pid

def cache_status(action='activity', dt=60):
    rpid   = read_pid(name='cache')
    cache = Cache()
    pid   = cache.get_pid()
    ret   = cache.get_recent(dt=dt)
    status= cache.get_cache_status()
    if pid != rpid:
        status = status + ' (pid not found)'

    cache.close()
    msg = '%i changed PVs cached in past %i seconds.  PID=%i  Status=%s'
    if 'check' == action:
        print(len(ret))
    else:
        if 'activity' == action:
            for r in ret:
                stime = tformat(r['ts'],format="%H:%M:%S")
                print("  %s   %.29s = %s" % (stime, r['pvname']+' '*20,r['value']))
        print(msg % (len(ret), int(dt), pid, status))


def show_status(a, cache_time=60, archive_minutes=10):
    cache_info = dict(a.cache.get_info(process='cache').items())
    cache_info.update({ 'ncache': len(a.cache.get_values(time_ago=cache_time)),
                        'cache_time': cache_time})
    arch_info = dict(a.cache.get_info(process='archive').items())
    arch_info.update({ 'narch': a.get_nchanged(minutes=archive_minutes),
                       'arch_time': archive_minutes})

    print("""Cache: '{status:s}', process_id : {pid:d}
   last update: {datetime:s}, values cached in past {cache_time:d} seconds : {ncache:d}
    """.format(**cache_info))

    
    print("""Archiver: '{status:s}', process_id : {pid:d}
   last update: {datetime:s}, values archived in past {arch_time:d} minutes: {narch:d}
    """.format(**arch_info))


def drop_pv(pvname):
    dbconn = cpool.get()
    Archiver(dbconn=dbconn).drop_pv(pvname)
    MasterDB(dbconn=dbconn).drop_pv(pvname)

def start_archiver(a, force=False):
    if not force:
        nchanged  = a.get_nchanged(minutes=2)
        if nchanged > 5:
            print("Archive appears to be running... try 'restart'?")
            return
    a.mainloop()

def start_cache(a, force=False):
    if not force:
        nchanged  = a.cache.get_values(time_ago=15)
        if nchanged > 5:
            print("Cache appears to be running... try 'restart'?")
    a.cache.mainloop()
        
        
def main():
    parser = ArgumentParser(prog='pvarch',
                            description='control EpicsAarchiver processes',
                            add_help=False)
    parser.add_argument('-h', '--help', dest='help', action='store_true',
                        default=False, help='show help')
    parser.add_argument('options', nargs='*')
    
    args = parser.parse_args()
    if args.help:
        print("""pvarch: control EpicsArchiver processes
    pvarch -h            shows this message.
    pvarch status        shows cache and archiving status, some recent statistics.
    pvarch check         print # of archivedsin past 10 minutes. Should be >1!

    pvarch start         start the archiving process
    pvarch stop          stop the archiving process
    pvarch restart       restart the archiving process
    pvarch next          restart with 'next run' of data archives
    pvarch setinfo       set the run information for the most recent run

    pvarch add_pv        add a PV to the cache and archive
    pvarch add_pvfile    read a file of PVs to add to the Archiver

    pvarch drop_pv       remove a PV from cahce and archive

    pvarch list          prints a list of recent data archives
    pvarch save          save a list of recent data archives
    pvarch clean         clean up temporary data files used for web plotting.

    pvarch cache start        start cache process (if it's not already running)
           cache stop         stop  cache process
           cache restart      restart cache process
           cache status   t   show # of PVs cached in past t seconds (default=60)
           cache activity t   show list of PVs cached in past t seconds (default=60)
    """)

        sys.exit()
    
    cmd = args.options.pop()
    t0 = time.time()
    a = Archiver()
    
    if 'status' == cmd:
        show_status(a)

    elif 'check' == cmd:
        print(a.get_nchanged(minutes=10))

    elif cmd == 'start':
        start_archiver(a)

    elif cmd == 'stop':
        a.cache.set_info(process='archive', status='stopping')
        time.sleep(1)
        a.cache.set_info(process='archive', status='offline')

    elif cmd == 'restart':
        a.cache.set_info(process='archive', status='stopping')
        time.sleep(1)
        a.cache.set_info(process='archive', status='offline')
        time.sleep(1)
        start_archiver(a, force=True)

    elif 'next' == cmd:
        next_archive()
        print("should now run 'pvarch setinfo'")
        # set_runinfo()

    elif 'save' == cmd:
        save_archives(args)

    elif 'list' == cmd:
        list_archives()

    elif 'setinfo' == cmd:
        set_runinfo()

    elif 'add_pv' == cmd:
        for pv in args:
            a.cache.add_pv(pv)
        if len(args)>1:
            a.cache.set_allpairs(args)

        time.sleep(0.1)
        print("Wait for PV to get to cache...")
        a.cache.process_requests()

    elif 'add_pvfile' == cmd:
        for pvfile in args:
            add_pvfile(pvfile)

    elif 'drop_pv' == cmd:
        for pv in args:
            drop_pv(pv)

    elif 'cache' == cmd:
        action = args.pop(0)

        if action not in ('start','stop','restart','status','activity','check'):
            print("'pvarch cache' needs one of start, stop, restart, status, check, activity")
            print("    Try 'pvarch -h' ")

        if action in ('status','check','activity'):
            dt = 60
            if len(args)>0: dt = args.pop(0)
            cache_status(action=action,dt=float(dt))
        elif action ==  'restart':
            run_cache(action='stop')
            time.sleep(3)
            run_cache(action='start')
        else:
            run_cache(action=action)

    else: print("pvarch  unknown command '%s'.    Try 'pvarch -h'" % cmd)

main()
